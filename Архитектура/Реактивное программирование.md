**Реактивное программирование** связано с [декларативным](https://github.com/devSchacht/translations/tree/master/glossary_of_modern_javaScript_concepts_part_1#%D0%98%D0%BC%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5-%D0%B8-%D0%B4%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (что делать, а не как) наблюдением и реагированием на поступающие события во времени. Реактивность — это способность реагировать на какие-либо изменения. В первую очередь, об изменениях данных. **Тоесть способность автоматически обновлять состояние или интерфейс в ответ на изменения данных, без явного вызова функций обновления.**

Данный пример показывает реактивный подход. В отличие от императивного подхода, реактивный подход строится на push стратегии распространения изменений. Push стратегия подразумевает, что в случае изменения данных эти самые изменения будут “проталкиваться”, и зависимые от них данные будут автоматически обновляться.

```js
let a = 2;

let b = 3;

let sum = a + b;

console.log(sum); // 5

a = 3;

console.log(sum); // 6 - значение переменной sum автоматически пересчиталось
```

“Реактивное программирование — парадигма программирования, ориентированная на потоки данных и распространение изменений”. Из этого определения можно сделать вывод, что реактивность базируется на двух основных “китах”.

Мы слушаем событие keyup и кладем объект события в наш массив. Со временем наш массив может содержать тысячи объектов KeyboardEvent. При этом стоит отметить, что наш массив отсортирован по времени — индекс более поздних событий больше, чем индекс более ранних. Такой массив представляет собой упрощенную модель потока данных. Почему упрощенную? Потому что массив умеет только хранить данные. Еще мы можем проитерировать массив и как-то обработать его элементы. Но массив не может сообщить нам о том, что в него был добавлен новый элемент. Для того, чтобы узнать, были ли добавлены новые данные в массив, нам придется снова проитерировать его.  

```js
const input = document.querySelector('input'); // получаем ссылку на элемент

const eventsArray = [];

input.addEventListener('keyup',
	event => eventsArray.push(event)
); // пушим каждое событие в массив eventsArray
```
  
Но что, если бы наш массив умел сообщать нам о том, что в него поступили новые данные? Такой массив можно было бы с полной уверенностью назвать потоком. Итак, мы подошли к определению потока. Поток — это массив данных, отсортированных по времени, который может сообщать о том, что данные изменились.

Подробнее тут https://habr.com/ru/articles/438642/ на RxJs.

Велосипед для иллюстрации reactive programming через патерн Observer.

```js
class Observer {
	constructor () {
		this.observer = [];
	}
	
	subscribe = (observer) => {
		this.observer.push(observer);
	}
	
	unsubscribe = (observer) => {
		this.observer = this.observer.filter(subscriber => subscriber !== observer);
	}
	
	broadcast = (data) => {
		this.observer.forEach((observer) => observer.update(data));
	}
}

class DataList {
	constructor(name) {
		this.name = name;
		this.data = [];
	}

	update(data) {
		console.log(`${this.name} получил обновление:`, data);
		this.data.push(data);
	}
}

const observer = new Observer();
const dataList1 = new DataList('DataList1');
const dataList2 = new DataList('DataList2');

observer.subscribe(dataList1);
observer.subscribe(dataList2);

observer.broadcast(5);
observer.broadcast(8);
```

ограничения этого примера

1. **Нет асинхронности:**
    - В данном коде обновления происходят синхронно. Для полной реактивности в реальных приложениях часто используется 
2. **Нет управления потоками данных:**
    - В отличие от реактивных библиотек, таких как RxJS, здесь нет встроенных инструментов для трансформации данных (например, `map`, `filter`).

  
  **Как работает Redux:**
    - Redux использует централизованное хранилище (store), где хранится всё состояние приложения.
    - Изменения состояния происходят через **диспатчи (dispatch)**, которые отправляют **действия (actions)**.
    - Reducer обновляет состояние на основе действий.
    - Компоненты подписываются на состояние и обновляются через библиотеку, такую как React Redux.
- **Реактивность в Redux:**
    
    - Redux сам по себе не предоставляет "магической" реактивности.
    - Реактивность обеспечивается благодаря подписке компонентов на изменения состояния с помощью `connect` или `useSelector` (в React).
    - Любое изменение требует явного вызова `dispatch`, что делает процесс управления состоянием детерминированным и предсказуемым.
- **Особенности:**
    
    - Состояние неизменно (immutable), и любое изменение приводит к созданию нового объекта состояния.
    - Реактивность в Redux требует больше ручной работы, так как вы должны явно описывать, как состояние меняется.



- **Как работает MobX:**
    
    - MobX использует **объекты с наблюдаемыми свойствами** (`observable`), которые автоматически отслеживают изменения.
    - Компоненты подписываются на эти свойства через `observer` (в React) или автоматически, если вы используете декораторы.
    - Любое изменение наблюдаемого свойства автоматически обновляет связанные компоненты.
- **Реактивность в MobX:**
    
    - Реактивность в MobX встроена. Когда изменяется наблюдаемое свойство, все подписчики автоматически получают обновления.
    - Вам не нужно явно вызывать `dispatch` или описывать, как изменяется состояние — MobX делает это "магически".
- **Особенности:**
    
    - Состояние может быть изменяемым (mutable), что делает работу более естественной и похожей на обычное программирование.
    - Реактивность более автоматическая, но это может привести к менее предсказуемому поведению в больших приложениях.
      
      

https://github.com/devSchacht/translations/blob/master/articles/glossary_of_modern_javaScript_concepts_part_1/readme.md


https://habr.com/ru/companies/ruvds/articles/737114/