Это ключевое слово значение которого, зависет от контекста в котором оно применяется.
Обращаясь к ключевому слову `this` в глобальной области видимости, оно будет привязано к глобальному контексту

```js
console.log(this)
```

Когда `this` используется внутри объекта, это ключевое слово ссылается на сам объект.

```js
var dog = {
  name: 'Chester',
  breed: 'beagle',
  intro: function(){
    console.log(this);
  }
};

dog.intro();
```
```
// в консоль выводится представление объекта dog со всеми его свойствами и методами
// {name: "Chester", breed: "beagle", intro: ƒ}
//    breed:"beagle"
//    intro:ƒ ()
//    name:"Chester"
//    __proto__:Object
```


Применение `this` во вложенных объектах относиться к тому объекту, в методе которого оно используется.
Стрелочные функции ведут себя не так, как обычные функции.
```js
var objReg = {
	hello: function() {
		return this;
	}
};

var objArrow = {
	hello: () => this
};

console.log(objReg.hello()); // возвращает, как и ожидается, объект objReg
console.log(objArrow.hello()); // возвращает объект Window!
```

this в обычных функциях

```js
function foo() {
	console.log(this);
}

foo() //global object
```

```js
'use strict';
function foo() { 
	console.log(this); 
} 

foo() //undefined
```

Когда обычная функция находится в глобальной области видимости, то ключевое слово `this`, использованное в ней, будет привязано к объекту `window`. Однако если функция выполняется в строгом режиме, то в `this` будет записано `undefined`, так как в этом режиме запрещены привязки по умолчанию.

Рассмотрим пример с уже известным нам объектом `dog`. В качестве метода этого объекта можно назначить функцию `chase`, объявленную за его пределами. Тут в объекте `dog` никаких методов не было, до тех пор, пока мы не создали метод `foo`, которому назначена функция `chase`. Если теперь вызвать метод `dog.foo`, то будет вызвана функция `chase`. При этом ключевое слово `this`, к которому обращаются в этой функции, указывает на объект `dog`. А функция `chase`, при попытке её вызова как самостоятельной функции, будет вести себя неправильно, так как при таком подходе `this` будет указывать на глобальный объект, в котором нет тех свойств, к которым мы, в этой функции, обращаемся через `this`.

```js
var dog = {
	breed: 'Beagles',
	lovesToChase: 'rabbits'
};

function chase() {
	console.log(this.breed + ' loves chasing ' + this.lovesToChase + '.');
}

dog.foo = chase;
dog.foo(); 
chase(); // undefined
```

При вызове функции-конструктора с использованием ключевого слова `new` ключевое слово `this` указывает на новый объект, который, после некоторой работы над ним, будет возвращён из этой функции.

## Вопросы

1. Отличия в сторогом и не в строгом режиме.
   



