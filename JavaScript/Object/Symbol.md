По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы.

«Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции `Symbol()`:

```js
let id = Symbol("id");

alert(id);
```

Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.

```js
let id1 = Symbol("id"); 
let id2 = Symbol("id"); 

alert(id1 === id2);
```

Символы позволяют создавать «скрытые» свойства объектов, к которым нельзя нечаянно обратиться и перезаписать их из других частей программы.

```js
let user = {
	name: 'artem'
};

let id = Symbol('id');

user[id] = 1;

console.log(user) // { name: 'artem', [Symbol(id)]: 1 }
console.log(user.id) // undefined
console.log(user['id']) // undefined
console.log(user[id]) // 1
```

Но к символу сложно нечаянно обратиться, так как  нужн конкретный `let id`

Свойства, чьи ключи – символы, не перебираются циклом `for..in`.

```js
let id = Symbol("id");
let user = {
	name: "Вася",
	age: 30,
	[id]: 123
};

for (let key in user) {
	alert(key); // name, age (свойства с ключом-символом нет среди перечисленных)
}

// хотя прямой доступ по символу работает
alert( "Напрямую: " + user[id] );
```

`Object.keys(user)` также игнорирует символы.


Например, разные части нашего приложения хотят получить доступ к символу `"id"`, подразумевая именно одно и то же свойство. Для этого существует _глобальный реестр символов_. Мы можем создавать в нём символы и обращаться к ним позже, и при каждом обращении нам гарантированно будет возвращаться один и тот же символ. Для чтения (или, при отсутствии, создания) символа из реестра используется вызов `Symbol.for(key)`. Он проверяет глобальный реестр и, при наличии в нём символа с именем `key`, возвращает его, иначе же создаётся новый символ `Symbol(key)` и записывается в реестр под ключом `key`.

читать больше
https://learn.javascript.ru/symbol

## [Системные символы](https://learn.javascript.ru/symbol#sistemnye-simvoly)

Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.

Эти символы перечислены в спецификации в таблице [Well-known symbols](https://tc39.github.io/ecma262/#sec-well-known-symbols):

- `Symbol.hasInstance`
- `Symbol.isConcatSpreadable`
- `Symbol.iterator`
- `Symbol.toPrimitive`
- …и так далее.

Технически символы скрыты не на 100%. Существует встроенный метод [Object.getOwnPropertySymbols(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) – с его помощью можно получить все свойства объекта с ключами-символами. Также существует метод [Reflect.ownKeys(obj)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys), который возвращает _все_ ключи объекта, включая символьные