Это объект у которого есть три состояния: 
	![[Pasted image 20241112121844.png]]

На `promise` можно навешивать колбэки двух типов:
- `onFulfilled` – срабатывают, когда `promise` в состоянии «выполнен успешно».
- `onRejected` – срабатывают, когда `promise` в состоянии «выполнен с ошибкой».
  
promise`.``then``(`onFulfilled`,` onRejected`)`
- `onFulfilled` – функция, которая будет вызвана с результатом при `resolve`.
- `onRejected` – функция, которая будет вызвана с ошибкой при `reject`.
`// onFulfilled сработает при успешном выполнении` promise`.``then``(`onFulfilled`)` `// onRejected сработает при ошибке` promise`.``then``(``null``,` onRejected`)`


Если в функции промиса происходит синхронный `throw` (или иная ошибка), то вызывается `reject`:

```js
	let p = new Promise((resolve, reject) => {
		throw new Error("oy");
	});
	
	p.catch(alert);
 ```

_Промисификация_ – это когда берут асинхронную функциональность и делают для неё обёртку, возвращающую промис. Это упрощает работу с асинхронным кодом.

```js 
return new Promise((resolve, reject) => {
	setTimeout(() => {
		fn();
		resolve();
	}, ms)
});
```

```js
// Промификация setTimeout
const delay = (ms) => {
	return new Promise((resolve) => {
		setTimeout(() => {
			resolve('Hello!');
		}, ms);
	});
}

delay(1000).then(alert);
```


Если очередной `then` вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.
Если мы хотим, чтобы после `setTimeout` `(*)` асинхронная цепочка могла быть продолжена, то последний `then` тоже должен вернуть промис. Это общее правило: если внутри `then` стартует новый асинхронный процесс, то для того, чтобы оставшаяся часть цепочки выполнилась после его окончания, мы должны вернуть промис. Нужно вызвать reject или resolve.
 
 # **Promise API**
 
 6 статических методов

1. Вызов `Promise.all(iterable)` получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результато. Выполняет параллельно.

2. Вызов `Promise.race`, как и `Promise.all`, получает итерируемый объект с промисами, которые нужно выполнить, и возвращает новый промис.Но, в отличие от `Promise.all`, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются. Выполняет параллельно.
   
3. `Promise.allSettled(promises)` – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
    - `status`: `"fulfilled"`, если выполнен успешно или `"rejected"`, если ошибка,
    - `value` – результат, если успешно или `reason` – ошибка, если нет.
    Выполняет параллельно.
      
4. `Promise.any(promises)` (добавлен недавно) – ожидает первый _успешно выполненный_ промис, который становится его результатом, остальные игнорируются. Если все переданные промисы отклонены, [`AggregateError`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/AggregateError) становится ошибкой `Promise.any`. Выполняет параллельно.
   
5. Вызов `Promise.resolve(value)` создаёт успешно выполнившийся промис с результатом `value`. Он аналогичен конструкции: 
   ```js
	new Promise((resilve) => resolve(value));
```
   `Promise.resolve` используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть. Например:
   ```js
   Promise.resolve(window.location).then(httpGet).then(alert);
```

6. Аналогично `Promise.reject(error)` создаёт уже выполнившийся промис, но не с успешным результатом, а с ошибкой `error`.