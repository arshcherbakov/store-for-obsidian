useState - хук, который позволяет добавить переменную состояния в компонент.

```js
const [state, setState] = useState(initialState);
```

1. Переменная **state** для сохранения данных между рендерами.
2. Функция **set** для обновления переменной и запуска React для повторного рендеринга компонента.

Установка состояния не изменяет переменную в существующем рендере, но запрашивает новый рендер, а уже после изменяет состояние.

Локальные переменные не заменят state, потому что 
1. **Локальные переменные не сохраняются между рендерами.** Когда React рендерит этот компонент во второй раз, он рендерит его с нуля - он не учитывает никаких изменений в локальных переменных.
2. **Изменения локальных переменных не вызывают рендеринга.** React не понимает, что ему нужно снова рендерить компонент с новыми данными.
   
Функция `set`, возвращаемая `useState`, позволяет обновить состояние до другого значения и вызвать повторный рендеринг. Можно передать следующее состояние напрямую или функцию, которая вычисляет его на основе предыдущего состояния:

```js
const [name, setName] = useState('Edward');

function handleClick() {
    setName('Taylor');
    setAge((prev) => prev + 1);
    // ...
}
```

**Параметры**
  `nextState`: Значение, которое вы хотите видеть в состоянии. Это может быть значение любого типа, но есть **особое поведение для функций**.
    - Если вы передадите функцию в качестве `nextState`, она будет рассматриваться как _функция обновления_. Она должна быть чистой, принимать состояние ожидания в качестве единственного аргумента и возвращать следующее состояние. React поместит вашу функцию обновления в очередь и перерендерит ваш компонент. Во время следующего рендеринга React вычислит следующее состояние, применив все стоящие в очереди функции обновления к предыдущему состоянию.
      
#### Возврат

  Функции `set` не имеют возвращаемого значения.
  
  #### Предостережения

- Функция `set` **только обновляет переменную состояния для _следующего_ рендера**. Если вы прочитаете переменную состояния после вызова функции `set`, вы получите старое значение, которое было на экране до вашего вызова.
    
- Если новое значение, которое вы предоставили, идентично текущему `состоянию`, что определяется сравнением [`Object.is`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/is), React **пропустит повторное отображение компонента и его дочерних элементов.** Это оптимизация. Хотя в некоторых случаях React может потребоваться вызвать ваш компонент, прежде чем пропустить дочерние компоненты, это не должно повлиять на ваш код.

- React [batches state updates.](https://reactdev.ru/learn/queueing-a-series-of-state-updates/) Он обновляет экран **после того, как все обработчики событий запущены** и вызвали свои функции `set`. Это предотвращает множественные повторные рендеринги во время одного события. В редких случаях, когда вам нужно заставить React обновить экран раньше, например, для доступа к DOM, вы можете использовать [`flushSync`](https://reactdev.ru/reference/react-dom/flushSync/).
    
- Вызов функции `set` _во время рендеринга_ разрешен только внутри текущего рендерингового компонента. React отбросит его вывод и немедленно попытается отрендерить его снова с новым состоянием. Этот паттерн нужен редко, но вы можете использовать его для **сохранения информации из предыдущих рендеров**.
    
- В строгом режиме React будет **вызывать вашу функцию обновления дважды**, чтобы помочь вам найти случайные примеси. Это поведение только для разработчиков и не влияет на производство. Если ваша функция обновления является чистой (как и должно быть), это не должно повлиять на поведение. Результат одного из вызовов будет проигнорирован.

```js
function handleClick() {
    setAge(age + 1); // setAge(42 + 1)
    setAge(age + 1); // setAge(42 + 1)
    setAge(age + 1); // setAge(42 + 1)
}
```

Так как значение поменяеться после рендора, а не сразу в уже запущенном коде. Поэтому каждый вызов `setAge(age + 1)` становится `setAge(43)`. Решение этой проблемы использовать предыдущее значение(отложенное).  **Передать функцию _updater_** в `setAge` вместо следующего состояния:

```js
function handleClick() {
    setAge((prevAge) => prevAge + 1); // setAge(42 => 43)
    setAge((prevAge) => prevAge + 1); // setAge(43 => 44)
    setAge((prevAge) => prevAge + 1); // setAge(44 => 45)
}
```

Здесь `prevAge => prevAge + 1` - это функция обновления. Она берет отложенное состояние и вычисляет следующее состояние из него.

React помещает ваши функции обновления в [очередь](https://reactdev.ru/learn/queueing-a-series-of-state-updates/) Затем, во время следующего рендеринга, он будет вызывать их в том же порядке:

1. `a => a + 1` получит `42` в качестве ожидающего состояния и вернет `43` в качестве следующего состояния.
2. `a => a + 1` получит `43` как ожидающее состояние и вернет `44` как следующее состояние.
3. `a => a + 1` получит `44` как состояние ожидания и вернет `45` как следующее состояние.

Других обновлений в очереди нет, поэтому в конце React сохранит `45` как **текущее состояние**.

 **если вы дважды отобразите один и тот же компонент, каждая копия будет иметь полностью изолированное состояние!** Изменение одного из них не повлияет на другой.

State являеться мутируемым. Поэтому при работе с объектом его нужно копировать({...obj}), а если это маcсив, то использовать filter, toSort, [...array], и т.д. Если это усложняет разработку, то следует использовать библиотеку Immer.js. Хотя мутирование состояния может работать в некоторых случаях, дока react не рекомендуем этого делать. Вы должны рассматривать значение состояния, к которому вы имеете доступ во время рендеринга, как доступное только для чтения.

Чтобы действительно [вызвать повторный рендеринг](https://reactdev.ru/learn/state-as-a-snapshot/#setting-state-triggers-renders) в этом случае, **создайте _новый_ объект и передайте его в функцию установки состояния**
Сравнение состояние видимо идет через Object.is();

Почему мутирование состояния не рекомендуется в React?

Есть несколько причин:

- **Отладка:** Если вы используете `console.log` и не мутируете состояние, ваши прошлые логи не будут забиты недавними изменениями состояния. Таким образом, вы можете четко видеть, как изменялось состояние между рендерами.
- **Оптимизация:** Обычные [стратегии оптимизации React](https://reactdev.ru/reference/react/memo/) полагаются на пропуск работы, если предыдущие пропсы или состояние совпадают с последующими. Если вы никогда не изменяете состояние, то проверить, были ли изменения, можно очень быстро. Если `prevObj === obj`, вы можете быть уверены, что внутри него ничего не могло измениться.
- **Новые возможности:** Новые возможности React, которые мы создаем, зависят от того, что состояние [рассматривается как снимок](https://reactdev.ru/learn/state-as-a-snapshot/). Если вы мутируете прошлые версии состояния, это может помешать вам использовать новые возможности.
- **Изменения требований:** Некоторые возможности приложения, такие как реализация Undo/Redo, показ истории изменений или предоставление пользователю возможности вернуть форму к прежним значениям, проще сделать, если ничего не мутировать. Это происходит потому, что вы можете хранить в памяти прошлые копии состояния и использовать их повторно, когда это необходимо. Если вы начнете с мутативного подхода, такие функции, как эта, будет трудно добавить позже.
- **Простая реализация:** Поскольку React не полагается на мутацию, ему не нужно делать ничего особенного с вашими объектами. Ему не нужно перехватывать их свойства, всегда оборачивать их в прокси или выполнять другую работу при инициализации, как это делают многие "реактивные" решения. Именно поэтому React позволяет вам поместить любой объект в состояние - независимо от его размера - без дополнительных проблем с производительностью и корректностью.
  
Вы можете **сбросить состояние компонента, передав компоненту другой `key`.**