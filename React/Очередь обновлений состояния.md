

```js
import { useState } from 'react';

export default function Counter() {
    const [number, setNumber] = useState(0);

    return (
        <>
            <h1>{number}</h1>
            <button
                onClick={() => {
                    setNumber(number + 1);
                    setNumber(number + 1);
                    setNumber(number + 1); // тут обновит и будет 1
                }}
            >
                +3
            </button>
        </>
    );
}
```

**React ждет, пока будет выполнен _весь_ код внутри обработчика событий, прежде чем обрабатывать ваши обновления состояния.** Вот почему повторный рендеринг происходит только _после_ всех этих вызовов `setNumber()`. Это позволяет обновлять несколько переменных состояния - даже из нескольких компонентов - не вызывая слишком много [повторных рендеров](https://reactdev.ru/learn/render-and-commit/#re-renders-when-state-updates). Но это также означает, что пользовательский интерфейс не будет обновляться до тех пор, пока не завершится ваш обработчик событий и любой код в нем. Такое поведение, также известное как **батчинг**, заставляет ваше приложение React работать намного быстрее. 
**React не выполняет пакетную обработку _многочисленных_ намеренных событий, таких как клики** - каждый клик обрабатывается отдельно.

```js
<button onClick={() => {
    setNumber(number + 5);
    setNumber(n => n + 1);
}}>
```
Во время следующего рендеринга React просматривает очередь состояний:

|обновление в очереди|`n`|возвращает|
|---|---|---|
|"заменить на `5`"|`0` (неиспользуемый)|`5`|
|`n => n + 1`|`5`|`5 + 1 = 6`|
https://reactdev.ru/learn/queueing-a-series-of-state-updates/#what-happens-if-you-update-state-after-replacing-it